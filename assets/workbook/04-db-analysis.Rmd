```{r db-analysis, include = FALSE}
eval_db <- TRUE
```

```{r, eval = eval_db, include = FALSE}
library(connections)
library(RSQLite)
library(dplyr)
library(dbplyr)
```

# Databases and `dplyr`

## Intro to `connections`
*Use `connections` to open open a database connection*

1. Load the `connections` package
    ```{r, eval = eval_db}
    library(connections)
    ```

1. Use `connection_open()` to open a Database connection
    ```{r, eval = eval_db}
    con <- connection_open(RSQLite::SQLite(), "database/local.sqlite")
    ```
    
1. The RStudio Connections pane should show the tables in the database
<img src="images/04-conn-pane.png" align="center" width="400px"> 

## Table reference
*Use the `dplyr`'s `tbl()` command*

1. Load the `dplyr` package
    ```{r, eval = eval_db}
    library(dplyr)
    ```

1. Use the `tbl()` command to call the **transactions** table
    ```{r, eval = eval_db}
    tbl(con, "transactions")
    ```

1. Add `in_schema()` as an argument to `tbl()` to specify the schema.  The default schema is called: "main"
    ```{r, eval = eval_db}
    tbl(con, in_schema("main", "transactions"))
    ```

1. Load the results from the `tbl()` command to a variable called `transactions` 
    ```{r, eval = eval_db}
    transactions <- tbl(con, "transactions")
    ```
    
    
## Under the hood 
*Use `show_query()` to preview the SQL statement that will be sent to the database*

1. Use `show_query()` to preview SQL statement that actually runs when we run `transactions` as a command
    ```{r, eval = eval_db}
    show_query(transactions)
    ```

1. Easily view the resulting query by adding `show_query()` in another piped command
    ```{r, eval = eval_db}
    transactions %>%
      show_query()
    ```

1. Insert `head()` in between the two statements to see how the SQL changes
    ```{r, eval = eval_db}
    transactions %>%
      head() %>%
      show_query()
    ```

1. Use `sql_render()` and `simulate_mssql()` to see how the SQL statement changes from vendor to vendor
    ```{r, eval = eval_db}
    transactions %>%
      head() %>%
      sql_render(con = simulate_mssql()) 
    ```

1. Use `explain()` to explore the query plan
    ```{r, eval = eval_db}
    transactions %>% 
      head() %>% 
      explain()
    ```
    
## Un-translated R commands
*Review of how `dbplyr` handles R commands that have not been translated into a like-SQL command*

1. Preview how `Sys.time()` is translated
    ```{r, eval = eval_db}
    transactions %>%
      mutate(today = Sys.time()) %>%
      show_query()
    ```

1. Use SQLite's native commands, in this case `date()`
    ```{r, eval = eval_db}
    transactions %>%
      mutate(today = date('now')) %>%
      show_query()
    ```

1. Run the `dplyr` code to confirm it works
    ```{r, eval = eval_db}
    transactions %>%
      mutate(today = date('now')) %>%
      select(today) %>%
      head()
    ```

## Using bang-bang
*Intro on passing unevaluated code to a dplyr verb*

1. Preview how `Sys.time()` is translated when prefixing `!!`
    ```{r, eval = eval_db}
    transactions %>%
      mutate(today = !!Sys.time()) %>%
      show_query()
    ```

1. Preview how `Sys.time()` is translated when prefixing `!!`
    ```{r, eval = eval_db}
    transactions %>%
      mutate(today = !!Sys.time()) %>%
      select(today) %>%
      head()
    ```

## Table joins
*Quick review of how to join database tables with `dplyr`*

1. Create a `tbl()` pointer to the **dates** table
    ```{r, eval = eval_db}
    dates <- tbl(con, "dates")
    ```

1. Use `inner_join()` to link the `dates` and `transactions` variables. Use the *step_id* field to join the tables
    ```{r, eval = eval_db}
    dates %>%
      inner_join(transactions, by = "step_id")
    ```

1. Create a `tbl()` pointer to the **products** table
    ```{r, eval = eval_db}
    products <- tbl(con, "products")
    ```

1. Join the `dates`, `transactions` and `products` variables. Use *product_id* to as the identifier for the `products` data
    ```{r, eval = eval_db}
    dates %>%
      inner_join(transactions, by = "step_id") %>%
      inner_join(products, by = "product_id")
    ```

1. Create a `tbl()` pointer to the **customers** table
    ```{r, eval = eval_db}
    customers <- tbl(con, "customers")
    ```

1. Join the `dates`, `transactions`, `products` and `customers` variables. Use *customer_id* to as the identifier for the `customers` data
    ```{r, eval = eval_db}
    dates %>%
      inner_join(transactions, by = "step_id") %>%
      inner_join(products, by = "product_id") %>%
      inner_join(customers, by = "customer_id")
    ```


## Custom view
*Create a view of the dataset aggregated by orders*

1. Join the `transactions` and `products` variables
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") 
    ```

1. Add a grouping step, use *order_id* as the grouping field, then summarize by the total of *price*, name the new aggregation: *order_total*
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      group_by(order_id) %>%
      summarise(order_total = sum(price))
    ```

1. Add the number of products per order to the summarization, name the new aggregation: *order_qty*
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      group_by(order_id) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Add a table join to the `dates` variable
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      inner_join(dates, by = "step_id") %>%
      group_by(order_id) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Add *order_date*, *order_date_year*, and *order_date_month* to the grouping
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      inner_join(dates, by = "step_id") %>%
      group_by(order_id, order_date, order_date_year, order_date_month) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Add a join to the `customers` variable
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      inner_join(dates, by = "step_id") %>%
      inner_join(customers, by = "customer_id") %>%
      group_by(order_id, order_date, order_date_year, order_date_month) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Add *customer_name* and *customer_id* to the grouping
    ```{r, eval = eval_db}
    transactions %>%
      inner_join(products, by = "product_id") %>%
      inner_join(dates, by = "step_id") %>%
      inner_join(customers, by = "customer_id") %>%
      group_by(order_id, order_date, order_date_year, 
               order_date_month, customer_id, customer_name) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Assign the entire code segment to a variable called: `orders`
    ```{r, eval = eval_db}
    orders <- transactions %>%
      inner_join(products, by = "product_id") %>%
      inner_join(dates, by = "step_id") %>%
      inner_join(customers, by = "customer_id") %>%
      group_by(order_id, order_date, order_date_year, 
               order_date_month, customer_id, customer_name) %>%
      summarise(order_total = sum(price), order_qty = n())
    ```

1. Preview the resulting SQL of the `orders` variable
    ```{r, eval = eval_db}
    show_query(orders)
    ```

1. Request the SQL plan of `order`, using `explain()`
    ```{r, eval = eval_db}
    explain(orders)
    ```

1. Close the connection
    ```{r, eval = eval_db}
    connection_close(con)
    ```

