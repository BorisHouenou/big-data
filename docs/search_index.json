[
["index.html", "Big Data with R - Exercise book", " Big Data with R - Exercise book This 2-day workshop covers how to analyze large amounts of data in R. We will focus on scaling up our analyses using the same dplyr verbs that we use in our everyday work. We will use dplyr with data.table, databases, and Spark. We will also cover best practices on visualizing, modeling, and sharing against these data sources. Where applicable, we will review recommended connection settings, security best practices, and deployment options. In this 2-day workshop, attendees will learn how to connect to and analyze large scale data "],
["introduction-to-vroom.html", "1 Introduction to vroom 1.1 vroom basics 1.2 Load multiple files 1.3 Load and modify multiple files", " 1 Introduction to vroom 1.1 vroom basics Load data into R using vroom Load the vroom() library library(vroom) Use the vroom() function to read the transactions_1.csv file from the /usr/share/class/files folder vroom(&quot;/usr/share/class/files/transactions_1.csv&quot;) ## Observations: 50,000 ## Variables: 14 ## chr [4]: customer_name, customer_phone, date_month_name, date_day ## dbl [9]: order_id, customer_id, customer_cc, customer_lon, customer_lat, date_year, date_... ## date [1]: date ## ## Call `spec()` for a copy-pastable column specification ## Specify the column types with `col_types` to quiet this message ## # A tibble: 50,000 x 14 ## order_id customer_id customer_name customer_phone customer_cc customer_lon ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 2 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 3 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 4 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 5 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 6 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 7 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 8 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 9 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## 10 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## # … with 49,990 more rows, and 8 more variables: customer_lat &lt;dbl&gt;, date &lt;date&gt;, ## # date_year &lt;dbl&gt;, date_month &lt;dbl&gt;, date_month_name &lt;chr&gt;, date_day &lt;chr&gt;, ## # product_id &lt;dbl&gt;, price &lt;dbl&gt; Use the id argument to add the file name to the data frame. Use file_name as the argument’s value vroom(&quot;/usr/share/class/files/transactions_1.csv&quot;, id = &quot;file_name&quot;) ## Observations: 50,000 ## Variables: 15 ## chr [4]: customer_name, customer_phone, date_month_name, date_day ## dbl [9]: order_id, customer_id, customer_cc, customer_lon, customer_lat, date_year, date_... ## date [1]: date ## ## Call `spec()` for a copy-pastable column specification ## Specify the column types with `col_types` to quiet this message ## # A tibble: 50,000 x 15 ## file_name order_id customer_id customer_name customer_phone customer_cc ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 2 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 3 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 4 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 5 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 6 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 7 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 8 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 9 /usr/sha… 1003 80 Jessee Rodri… 539.176.3896 4.50e12 ## 10 /usr/sha… 1003 80 Jessee Rodri… 539.176.3896 4.50e12 ## # … with 49,990 more rows, and 9 more variables: customer_lon &lt;dbl&gt;, ## # customer_lat &lt;dbl&gt;, date &lt;date&gt;, date_year &lt;dbl&gt;, date_month &lt;dbl&gt;, ## # date_month_name &lt;chr&gt;, date_day &lt;chr&gt;, product_id &lt;dbl&gt;, price &lt;dbl&gt; Load the prior command into a variable called vr_transactions vr_transactions &lt;- vroom(&quot;/usr/share/class/files/transactions_1.csv&quot;, id = &quot;file_name&quot;) ## Observations: 50,000 ## Variables: 15 ## chr [4]: customer_name, customer_phone, date_month_name, date_day ## dbl [9]: order_id, customer_id, customer_cc, customer_lon, customer_lat, date_year, date_... ## date [1]: date ## ## Call `spec()` for a copy-pastable column specification ## Specify the column types with `col_types` to quiet this message vr_transactions ## # A tibble: 50,000 x 15 ## file_name order_id customer_id customer_name customer_phone customer_cc ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 2 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 3 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 4 /usr/sha… 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 ## 5 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 6 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 7 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 8 /usr/sha… 1002 6 Meggan Bruen 326-151-4331 4.96e15 ## 9 /usr/sha… 1003 80 Jessee Rodri… 539.176.3896 4.50e12 ## 10 /usr/sha… 1003 80 Jessee Rodri… 539.176.3896 4.50e12 ## # … with 49,990 more rows, and 9 more variables: customer_lon &lt;dbl&gt;, ## # customer_lat &lt;dbl&gt;, date &lt;date&gt;, date_year &lt;dbl&gt;, date_month &lt;dbl&gt;, ## # date_month_name &lt;chr&gt;, date_day &lt;chr&gt;, product_id &lt;dbl&gt;, price &lt;dbl&gt; Load the file spec into a variable called vr_spec, using the spec() command vr_spec &lt;- spec(vr_transactions) vr_spec ## cols( ## order_id = col_double(), ## customer_id = col_double(), ## customer_name = col_character(), ## customer_phone = col_character(), ## customer_cc = col_double(), ## customer_lon = col_double(), ## customer_lat = col_double(), ## date = col_date(format = &quot;&quot;), ## date_year = col_double(), ## date_month = col_double(), ## date_month_name = col_character(), ## date_day = col_character(), ## product_id = col_double(), ## price = col_double() ## ) 1.2 Load multiple files Load the fs and dplyr libraries library(fs) library(dplyr) List files in the /usr/share/class/files folder using the dir_ls() function dir_ls(&quot;/usr/share/class/files&quot;) ## /usr/share/class/files/transactions_1.csv ## /usr/share/class/files/transactions_2.csv ## /usr/share/class/files/transactions_3.csv ## /usr/share/class/files/transactions_4.csv ## /usr/share/class/files/transactions_5.csv In the dir_ls() function, use the glob argument to pass a wildcard to list CSV files only. Load to a variable named files files &lt;- dir_ls(&quot;/usr/share/class/files&quot;, glob = &quot;*.csv&quot;) Pass the files variable to vroom. Set the n_max argument to 1,000 to limit the data load for now vroom(files, n_max = 1000) ## Observations: 5,000 ## Variables: 14 ## chr [4]: customer_name, customer_phone, date_month_name, date_day ## dbl [9]: order_id, customer_id, customer_cc, customer_lon, customer_lat, date_year, date_... ## date [1]: date ## ## Call `spec()` for a copy-pastable column specification ## Specify the column types with `col_types` to quiet this message ## # A tibble: 5,000 x 14 ## order_id customer_id customer_name customer_phone customer_cc customer_lon ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 2 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 3 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 4 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 5 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 6 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 7 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 8 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 9 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## 10 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## # … with 4,990 more rows, and 8 more variables: customer_lat &lt;dbl&gt;, date &lt;date&gt;, ## # date_year &lt;dbl&gt;, date_month &lt;dbl&gt;, date_month_name &lt;chr&gt;, date_day &lt;chr&gt;, ## # product_id &lt;dbl&gt;, price &lt;dbl&gt; Add a col_types argument with vr_specs as its value vroom(files, n_max = 1000, col_types = vr_spec) ## # A tibble: 5,000 x 14 ## order_id customer_id customer_name customer_phone customer_cc customer_lon ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 2 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 3 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 4 1001 22 Dr. Birdie K… 684.226.0455 6.01e18 -122. ## 5 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 6 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 7 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 8 1002 6 Meggan Bruen 326-151-4331 4.96e15 -122. ## 9 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## 10 1003 80 Jessee Rodri… 539.176.3896 4.50e12 -122. ## # … with 4,990 more rows, and 8 more variables: customer_lat &lt;dbl&gt;, date &lt;date&gt;, ## # date_year &lt;dbl&gt;, date_month &lt;dbl&gt;, date_month_name &lt;chr&gt;, date_day &lt;chr&gt;, ## # product_id &lt;dbl&gt;, price &lt;dbl&gt; Use the col_select argument to pass a list object containing the following variables: order_id, date, customer_name, and price vroom(files, n_max = 1000, col_types = vr_spec, col_select = list(order_id, date, customer_name, price) ) ## # A tibble: 5,000 x 4 ## order_id date customer_name price ## &lt;dbl&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1001 2016-01-01 Dr. Birdie Kessler 9.88 ## 2 1001 2016-01-01 Dr. Birdie Kessler 7.53 ## 3 1001 2016-01-01 Dr. Birdie Kessler 5.64 ## 4 1001 2016-01-01 Dr. Birdie Kessler 4.89 ## 5 1002 2016-01-01 Meggan Bruen 6.48 ## 6 1002 2016-01-01 Meggan Bruen 6.7 ## 7 1002 2016-01-01 Meggan Bruen 4.27 ## 8 1002 2016-01-01 Meggan Bruen 7.38 ## 9 1003 2016-01-01 Jessee Rodriguez Jr. 7.53 ## 10 1003 2016-01-01 Jessee Rodriguez Jr. 5.21 ## # … with 4,990 more rows 1.3 Load and modify multiple files For files that are too large to have in memory, keep a summarization Use a for() loop to print the content of each vector inside files for(i in seq_along(files)) { print(files[i]) } ## /usr/share/class/files/transactions_1.csv ## /usr/share/class/files/transactions_2.csv ## /usr/share/class/files/transactions_3.csv ## /usr/share/class/files/transactions_4.csv ## /usr/share/class/files/transactions_5.csv Switch the print() command with the vroom command, using the same arguments, except the file name. Use the files variable. Load the results into a variable called transactions. for(i in seq_along(files)) { transactions &lt;- vroom(files[i], n_max = 1000, col_types = vr_spec, col_select = list(order_id, date, customer_name, price)) } Group transactions by order_id and get the total of price and the number of records. Name them total_sales and no_items respectively. Name the new variable orders for(i in seq_along(files)) { transactions &lt;- vroom(files[i], n_max = 1000, col_types = vr_spec, col_select = list(order_id, date, customer_name, price)) orders &lt;- transactions %&gt;% group_by(order_id) %&gt;% summarise(total_sales = sum(price), no_items = n()) } Define the orders variable as NULL prior to the for loop and add a bind_rows() step to orders to preserve each summarized view. orders &lt;- NULL for(i in seq_along(files)) { transactions &lt;- vroom(files[i], n_max = 1000, col_types = vr_spec, col_select = list(order_id, date, customer_name, price)) orders &lt;- transactions %&gt;% group_by(order_id) %&gt;% summarise(total_sales = sum(price), no_items = n()) %&gt;% bind_rows(orders) } Remove the transactions variable at the end of each cycle all_orders &lt;- NULL for(i in seq_along(files)) { transactions &lt;- vroom(files[i], n_max = 1000, col_types = vr_spec, col_select = list(order_id, date, customer_name, price)) orders &lt;- transactions %&gt;% group_by(order_id) %&gt;% summarise(total_sales = sum(price), no_items = n()) %&gt;% bind_rows(all_orders) rm(transactions) } Preview the orders variable orders ## # A tibble: 89 x 3 ## order_id total_sales no_items ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 41865 50.9 8 ## 2 41866 97.4 14 ## 3 41867 123. 16 ## 4 41868 91.9 14 ## 5 41869 63.2 10 ## 6 41870 75.2 10 ## 7 41871 70.6 10 ## 8 41872 60.4 8 ## 9 41873 76.2 10 ## 10 41874 75.7 12 ## # … with 79 more rows "],
["introduction-to-dtplyr.html", "2 Introduction to dtplyr 2.1 dtplyr basics 2.2 Object sizes 2.3 How dtplyr works 2.4 Working with dtplyr 2.5 Pivot data 2.6 The mutate() verb", " 2 Introduction to dtplyr 2.1 dtplyr basics Load data into R via data.table, and then wrap it with dtplyr Load the data.table, dplyr, dtplyr, purrr and fs libraries library(data.table) library(dplyr) library(dtplyr) library(purrr) library(fs) Read the transactions.csv file, from the /usr/share/class/files folder. Use the fread() function to load the data into a variable called transactions transactions &lt;- dir_ls(&quot;/usr/share/class/files&quot;, glob = &quot;*.csv&quot;) %&gt;% map(fread) %&gt;% rbindlist() Preview the data using glimpse() glimpse(transactions) ## Observations: 250,000 ## Variables: 14 ## $ order_id &lt;int&gt; 1001, 1001, 1001, 1001, 1002, 1002, 1002, 1002, 1003, 1… ## $ customer_id &lt;int&gt; 22, 22, 22, 22, 6, 6, 6, 6, 80, 80, 80, 80, 80, 80, 55,… ## $ customer_name &lt;chr&gt; &quot;Dr. Birdie Kessler&quot;, &quot;Dr. Birdie Kessler&quot;, &quot;Dr. Birdie… ## $ customer_phone &lt;chr&gt; &quot;684.226.0455&quot;, &quot;684.226.0455&quot;, &quot;684.226.0455&quot;, &quot;684.22… ## $ customer_cc &lt;int64&gt; 6011608753104063698, 6011608753104063698, 60116087531… ## $ customer_lon &lt;dbl&gt; -122.484, -122.484, -122.484, -122.484, -122.429, -122.… ## $ customer_lat &lt;dbl&gt; 37.7395, 37.7395, 37.7395, 37.7395, 37.7298, 37.7298, 3… ## $ date &lt;chr&gt; &quot;2016-01-01&quot;, &quot;2016-01-01&quot;, &quot;2016-01-01&quot;, &quot;2016-01-01&quot;,… ## $ date_year &lt;int&gt; 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016, 2… ## $ date_month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ date_month_name &lt;chr&gt; &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;, &quot;Jan&quot;,… ## $ date_day &lt;chr&gt; &quot;Friday&quot;, &quot;Friday&quot;, &quot;Friday&quot;, &quot;Friday&quot;, &quot;Friday&quot;, &quot;Frid… ## $ product_id &lt;int&gt; 6, 27, 30, 2, 17, 1, 5, 4, 27, 16, 30, 6, 11, 30, 30, 1… ## $ price &lt;dbl&gt; 9.88, 7.53, 5.64, 4.89, 6.48, 6.70, 4.27, 7.38, 7.53, 5… Load the dplyr and dtplyr libraries library(dplyr) library(dtplyr) Use the lazy_dt() to “wrap” the transactions variable, into a new variable called dt_transactions dt_transactions &lt;- lazy_dt(transactions) View the dt_transactions variable’s structure with glimpse() glimpse(dt_transactions) ## List of 7 ## $ parent :Classes &#39;data.table&#39; and &#39;data.frame&#39;: 250000 obs. of 14 variables: ## ..$ order_id : int [1:250000] 1001 1001 1001 1001 1002 1002 1002 1002 1003 1003 ... ## ..$ customer_id : int [1:250000] 22 22 22 22 6 6 6 6 80 80 ... ## ..$ customer_name : chr [1:250000] &quot;Dr. Birdie Kessler&quot; &quot;Dr. Birdie Kessler&quot; &quot;Dr. Birdie Kessler&quot; &quot;Dr. Birdie Kessler&quot; ... ## ..$ customer_phone : chr [1:250000] &quot;684.226.0455&quot; &quot;684.226.0455&quot; &quot;684.226.0455&quot; &quot;684.226.0455&quot; ... ## ..$ customer_cc :integer64 [1:250000] 6011608753104063698 6011608753104063698 6011608753104063698 6011608753104063698 4964180480255037 4964180480255037 4964180480255037 4964180480255037 ... ## ..$ customer_lon : num [1:250000] -122 -122 -122 -122 -122 ... ## ..$ customer_lat : num [1:250000] 37.7 37.7 37.7 37.7 37.7 ... ## ..$ date : chr [1:250000] &quot;2016-01-01&quot; &quot;2016-01-01&quot; &quot;2016-01-01&quot; &quot;2016-01-01&quot; ... ## ..$ date_year : int [1:250000] 2016 2016 2016 2016 2016 2016 2016 2016 2016 2016 ... ## ..$ date_month : int [1:250000] 1 1 1 1 1 1 1 1 1 1 ... ## ..$ date_month_name: chr [1:250000] &quot;Jan&quot; &quot;Jan&quot; &quot;Jan&quot; &quot;Jan&quot; ... ## ..$ date_day : chr [1:250000] &quot;Friday&quot; &quot;Friday&quot; &quot;Friday&quot; &quot;Friday&quot; ... ## ..$ product_id : int [1:250000] 6 27 30 2 17 1 5 4 27 16 ... ## ..$ price : num [1:250000] 9.88 7.53 5.64 4.89 6.48 6.7 4.27 7.38 7.53 5.21 ... ## ..- attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; ## $ vars : chr [1:14] &quot;order_id&quot; &quot;customer_id&quot; &quot;customer_name&quot; &quot;customer_phone&quot; ... ## $ groups : chr(0) ## $ implicit_copy: logi FALSE ## $ needs_copy : logi FALSE ## $ env :&lt;environment: R_GlobalEnv&gt; ## $ name : symbol _DT1 ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;dtplyr_step_first&quot; &quot;dtplyr_step&quot; 2.2 Object sizes Confirm that dtplyr is not making copies of the original data.table Load the lobstr library library(lobstr) Use obj_size() to obtain transactions’s size in memory obj_size(transactions) ## 23,019,560 B Use obj_size() to obtain dt_transactions’s size in memory obj_size(dt_transactions) ## 23,020,672 B Use obj_size() to obtain dt_transactions and transactions size in memory together obj_size(transactions, dt_transactions) ## 23,020,672 B 2.3 How dtplyr works Under the hood view of how dtplyr operates data.table objects Use dplyr verbs on top of dt_transactions to obtain the total sales by month dt_transactions %&gt;% group_by(date_month) %&gt;% summarise(total_sales = sum(price)) ## Source: local data table [?? x 2] ## Call: `_DT1`[, .(total_sales = sum(price)), keyby = .(date_month)] ## ## date_month total_sales ## &lt;int&gt; &lt;dbl&gt; ## 1 1 1120628. ## 2 2 562719. ## ## # Use as.data.table()/as.data.frame()/as_tibble() to access results Load the above code into a variable called by_month by_month &lt;- dt_transactions %&gt;% group_by(date_month) %&gt;% summarise(total_sales = sum(price)) Use show_query() to see the data.table code that by_month actually runs show_query(by_month) ## `_DT1`[, .(total_sales = sum(price)), keyby = .(date_month)] Use glimpse() to view how by_month, instead of modifying the data, only adds steps that will later be executed by data.table glimpse(by_month) ## List of 6 ## $ parent :List of 9 ## ..$ parent :List of 6 ## .. ..$ parent :List of 7 ## .. .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;dtplyr_step_first&quot; &quot;dtplyr_step&quot; ## .. ..$ vars : chr [1:14] &quot;order_id&quot; &quot;customer_id&quot; &quot;customer_name&quot; &quot;customer_phone&quot; ... ## .. ..$ groups : chr &quot;date_month&quot; ## .. ..$ implicit_copy: logi FALSE ## .. ..$ needs_copy : logi FALSE ## .. ..$ env :&lt;environment: R_GlobalEnv&gt; ## .. ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;dtplyr_step_group&quot; &quot;dtplyr_step&quot; ## ..$ vars : chr [1:2] &quot;date_month&quot; &quot;total_sales&quot; ## ..$ groups : chr &quot;date_month&quot; ## ..$ implicit_copy: logi TRUE ## ..$ needs_copy : logi FALSE ## ..$ env :&lt;environment: R_GlobalEnv&gt; ## ..$ i : NULL ## ..$ j : language .(total_sales = sum(price)) ## ..$ on : chr(0) ## ..- attr(*, &quot;class&quot;)= chr [1:2] &quot;dtplyr_step_subset&quot; &quot;dtplyr_step&quot; ## $ vars : chr [1:2] &quot;date_month&quot; &quot;total_sales&quot; ## $ groups : chr(0) ## $ implicit_copy: logi TRUE ## $ needs_copy : logi FALSE ## $ env :&lt;environment: R_GlobalEnv&gt; ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;dtplyr_step_group&quot; &quot;dtplyr_step&quot; 2.4 Working with dtplyr Learn data conversion and basic visualization techniques Use as_tibble() to convert the results of by_month into a tibble by_month %&gt;% as_tibble() ## # A tibble: 2 x 2 ## date_month total_sales ## &lt;int&gt; &lt;dbl&gt; ## 1 1 1120628. ## 2 2 562719. Load the ggplot2 library library(ggplot2) Use as_tibble() to convert before creating a line plot by_month %&gt;% as_tibble() %&gt;% ggplot() + geom_line(aes(date_month, total_sales)) 2.5 Pivot data Review a simple way to aggregate data faster, and then pivot it as a tibble Load the tidyr library library(tidyr) Group db_transactions by date_month and date_day, then aggregate price into total_sales dt_transactions %&gt;% group_by(date_month, date_day) %&gt;% summarise(total_sales = sum(price)) ## Source: local data table [?? x 3] ## Call: `_DT1`[, .(total_sales = sum(price)), keyby = .(date_month, date_day)] ## ## date_month date_day total_sales ## &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1 Friday 173787. ## 2 1 Monday 139347. ## 3 1 Saturday 177207. ## 4 1 Sunday 177685. ## 5 1 Thursday 156396. ## 6 1 Tuesday 141127. ## ## # Use as.data.table()/as.data.frame()/as_tibble() to access results Copy the aggregation code above, then collect it into a tibble, and then use pivot_wider() to make the date_day the column headers. dt_transactions %&gt;% group_by(date_month, date_day) %&gt;% summarise(total_sales = sum(price)) %&gt;% as_tibble() %&gt;% pivot_wider(names_from = date_day, values_from = total_sales) ## # A tibble: 2 x 8 ## date_month Friday Monday Saturday Sunday Thursday Tuesday Wednesday ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 173787. 139347. 177207. 177685. 156396. 141127. 155081. ## 2 2 80580. 83118. 84947. 80768. 77853. 79288. 76166. 2.6 The mutate() verb See how dtplyr creates a copy of the original data.table object in order to make the mutate operation work the same as it does on dtplr Use mutate() and show_query() to see the copy() command being used dt_transactions %&gt;% mutate(new_field = price / 2) %&gt;% show_query() ## copy(`_DT1`)[, `:=`(new_field = price/2)] Use lazy_dt() with the immutable argument set to FALSE to avoid the copy lazy_dt(transactions, immutable = FALSE) %&gt;% mutate(new_field = price / 2) %&gt;% show_query() ## `_DT2`[, `:=`(new_field = price/2)] "],
["introduction-to-database-connections.html", "3 Introduction to database connections 3.1 Connecting via DSN 3.2 Connect with a connection string 3.3 Secure connection details", " 3 Introduction to database connections 3.1 Connecting via DSN Connect using defined Data Source Name (DSN). This requires an ODBC driver. Load the DBI and odbc packages library(DBI) library(odbc) Use odbcListDatasources to list available DSNs odbcListDataSources() Use dbConnect to connect to a database using the odbc function and a DSN con &lt;- dbConnect(odbc(), &quot;Postgres DSN&quot;) Disconnect using dbDisconnect dbDisconnect(con) 3.2 Connect with a connection string Connect by specifying all connection details in dbConnect Use dbConnect and odbc to connect to a database, but this time all connection details are provided con &lt;- dbConnect(odbc(), driver = &quot;postgresql&quot;, host = &quot;localhost&quot;, user = &quot;postgres&quot;, pwd = &quot;postgres&quot;, port = 5432, database = &quot;postgres&quot;, bigint = &quot;integer&quot;) Disconnect using dbDisconnect dbDisconnect(con) 3.3 Secure connection details Use config, keyring, or environment variables to secure connection credentials Load the config package library(config) Get the current config using the get function and store the results in an object called config config &lt;- get() Use str to investigate the contents of config str(config) Connect using details provided in config con &lt;- dbConnect(odbc(), driver = config$driver, host = config$host, user = config$user, pwd = config$pwd, port = config$port, database = config$dbname, bigint = config$bigint) Disconnect using dbDisconnect dbDisconnect(con) Load the keyring package library(keyring) Store the database host, username, and password using keyring key_set(&quot;postgres&quot;, &quot;host&quot;) key_set(&quot;postgres&quot;, &quot;username&quot;) key_set(&quot;postgres&quot;, &quot;password&quot;) Use the stored credentials along with dbConnect to connect to the database con &lt;- dbConnect(odbc(), driver = &quot;postgresql&quot;, host = key_get(&quot;postgres&quot;, &quot;host&quot;), user = key_get(&quot;postgres&quot;, &quot;username&quot;), pwd = key_get(&quot;postgres&quot;, &quot;password&quot;), port = 5432, database = &quot;postgres&quot;, bigint = &quot;integer&quot;) Discnonect using dbDisconnect dbDisconnect(con) The .Renviron file contains entries to create environment variables for PG_HOST, PG_USER, and PG_PWD. These variables can be read using Sys.getenv(). Sys.getenv(&quot;PG_HOST&quot;) Connect to the database using the credentials stored in .Renviron and Sys.getenv() con &lt;- dbConnect(odbc(), driver = &quot;postgresql&quot;, host = Sys.getenv(&quot;PG_HOST&quot;), user = Sys.getenv(&quot;PG_USER&quot;), pwd = Sys.getenv(&quot;PG_PWD&quot;), port = 5432, database = &quot;postgres&quot;, bigint = &quot;integer&quot;) Discnonect using dbDisconnect dbDisconnect(con) "],
["introduction-to-dbi.html", "4 Introduction to DBI 4.1 Local database basics 4.2 Options for writing tables 4.3 Database operations 4.4 knitr SQL engine", " 4 Introduction to DBI 4.1 Local database basics Connecting and adding data to a database Load the DBI package library(DBI) Use dbConnect() to open a Database connection con &lt;- dbConnect(RSQLite::SQLite(), &quot;mydatabase.sqlite&quot;) Use dbListTables() to view existing tables, there should be 0 tables dbListTables(con) ## character(0) Use dbWriteTable() to create a new table using mtcars data. Name it db_mtcars dbWriteTable(con, &quot;db_mtcars&quot;, mtcars) Use dbListTables() to view existing tables, it should return db_mtcars dbListTables(con) ## [1] &quot;db_mtcars&quot; Use dbGetQuery() to pass a SQL query to the database dbGetQuery(con, &quot;select * from db_mtcars&quot;) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 11 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 12 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 13 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 14 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 15 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 16 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 17 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 18 32.4 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 19 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 20 33.9 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 21 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 22 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 23 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 24 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 25 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 26 27.3 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 27 26.0 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 28 30.4 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 29 15.8 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 30 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 31 15.0 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 32 21.4 4 121.0 109 4.11 2.780 18.60 1 1 4 2 Close the database connection using dbDisconnect() dbDisconnect(con) 4.2 Options for writing tables Understand how certain arguments in dbWriteTable() work Use dbConnect() to open a Database connection again con &lt;- dbConnect(RSQLite::SQLite(), &quot;mydatabase.sqlite&quot;) Use dbWriteTable() to re-create the db_mtcars table using mtcars data dbWriteTable(con, &quot;db_mtcars&quot;, mtcars) Error: Table db_mtcars exists in database, and both overwrite and append are FALSE Use the append argument in dbWriteTable() to add the data in the db_mtcars table dbWriteTable(con, &quot;db_mtcars&quot;, mtcars, append = TRUE) Using dbGetQuery(), check the current record count of db_mtcars, pass the following query: “select count() from db_mtcars” dbGetQuery(con, &quot;select count() from db_mtcars&quot;) ## count() ## 1 64 Use the overwrite argument to dbWriteTable() to replace the data in the db_mtcars table dbWriteTable(con, &quot;db_mtcars&quot;, mtcars, overwrite = TRUE) Check the record count of db_mtcars again dbGetQuery(con, &quot;select count() from db_mtcars&quot;) ## count() ## 1 32 4.3 Database operations Understand how to use dbSendStatement() to modify the database Use dbSendStatement() to pass a SQL commands that deletes any automatic car form db_mtcars: “delete from db_mtcars where am = 1”. Load the command to a variable called rs rs &lt;- dbSendStatement(con, &quot;delete from db_mtcars where am = 1&quot;) Call the rs variable to view information about the results of the requested change rs ## &lt;SQLiteResult&gt; ## SQL delete from db_mtcars where am = 1 ## ROWS Fetched: 0 [complete] ## Changed: 13 Use dbHasCompleted() to confirm that the job is complete dbHasCompleted(rs) ## [1] TRUE Use dbGetRowsAffected() to see the number of rows that were affected by the request dbGetRowsAffected(rs) ## [1] 13 Clear the results using dbClearResult() dbClearResult(rs) Confirm that the result set has been removed by calling the rs variable once more rs ## &lt;SQLiteResult&gt; ## EXPIRED Check the record count of db_mtcars again, the new count should be 19 (32 original records - 13 deleted records) dbGetQuery(con, &quot;select count() from db_mtcars&quot;) ## count() ## 1 19 4.4 knitr SQL engine See how to run SQL queries as code chunks Start a new code chunk, but using sql instead of r as the first argument of the chunk. Also add connection=con as another argument of the chunk. ```{sql, connection=con} select * from db_mtcars ``` Table 4.1: Displaying records 1 - 10 mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 Add the max.print options to the chunk, and set it to 5 ```{sql, connection=con, max.print = 5} select * from db_mtcars ``` Table 4.2: Displaying records 1 - 5 mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Set defaults for the sql chunks by using the knitr::opts_chunk$set() command knitr::opts_chunk$set(connection = &quot;con&quot;, max.print = 5) Run the same query in a new sql chunk, but without any other argument ```{sql} select * from db_mtcars ``` Table 4.3: Displaying records 1 - 5 mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 Store the results of the query into an R object called local_mtcars using the output.var option. select * from db_mtcars local_mtcars ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 2 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 3 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 4 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 5 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 6 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 7 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 8 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 9 16.4 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 10 17.3 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 11 15.2 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 12 10.4 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 13 10.4 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 14 14.7 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 15 21.5 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 16 15.5 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 17 15.2 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 18 13.3 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 19 19.2 8 400.0 175 3.08 3.845 17.05 0 0 3 2 Close the database connection using dbDisconnect() dbDisconnect(con) "],
["databases-and-dplyr.html", "5 Databases and dplyr 5.1 Intro to connections 5.2 Table reference 5.3 Under the hood 5.4 Un-translated R commands 5.5 Using bang-bang", " 5 Databases and dplyr 5.1 Intro to connections Use connections to open open a database connection Load the connections package library(connections) library(config) Use connection_open() to open a Database connection con &lt;- connection_open( RPostgres::Postgres(), host = &quot;localhost&quot;, user = get(&quot;user&quot;, config = &quot;datawarehouse&quot;), password = get(&quot;password&quot;, config = &quot;datawarehouse&quot;), port = 5432, dbname = &quot;postgres&quot;, bigint = &quot;integer&quot; ) The RStudio Connections pane should show the tables in the database 5.2 Table reference Use the dplyr’s tbl() command Load the dplyr package library(dplyr) Add in_schema() as an argument to tbl() to specify the schema. The default schema is called: “main” tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;customer&quot;)) ## # Source: table&lt;datawarehouse.customer&gt; [?? x 6] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## customer_id customer_name customer_phone customer_cc customer_lon customer_lat ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 Marilou Donne… 046-995-9387x… 4054106117… -122. 37.8 ## 2 2 Aubrey Gulgow… (020)136-2064 6759766520… -122. 37.7 ## 3 3 Arlis Koss 145.574.8189 8699968904… -122. 37.8 ## 4 4 Duwayne Walsh 737-897-1968x… 4091991124… -122. 37.7 ## 5 5 Nehemiah Doyl… (035)642-3662… 3709535249… -122. 37.7 ## 6 6 Meggan Bruen 326-151-4331 4964180480… -122. 37.7 ## 7 7 Tracie Swift … 776.442.3270x… 4354911637… -122. 37.8 ## 8 8 Karrie Donnel… 883.024.5322x… 4232403376… -122. 37.8 ## 9 9 Kip Eichmann (619)169-8761… 5177848238… -122. 37.7 ## 10 10 Ms. Ciarra Bo… 964-240-3124 4893126879… -122. 37.8 ## # … with more rows Load the results from the tbl() command that points the table called orders to a variable called orders orders &lt;- tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;orders&quot;)) 5.3 Under the hood Use show_query() to preview the SQL statement that will be sent to the database Use show_query() to preview SQL statement that actually runs when we run orders as a command show_query(orders) ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders Easily view the resulting query by adding show_query() in another piped command orders %&gt;% show_query() ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders Insert head() in between the two statements to see how the SQL changes orders %&gt;% head() %&gt;% show_query() ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders ## LIMIT 6 Use sql_render() and simulate_mssql() to see how the SQL statement changes from vendor to vendor orders %&gt;% head() %&gt;% sql_render(con = simulate_mssql()) ## &lt;SQL&gt; SELECT TOP(6) * ## FROM datawarehouse.orders Use explain() to explore the query plan orders %&gt;% head() %&gt;% explain() ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders ## LIMIT 6 ## ## &lt;PLAN&gt; ## Limit (cost=0.00..0.09 rows=6 width=12) ## -&gt; Seq Scan on orders (cost=0.00..1541.81 rows=100081 width=12) 5.4 Un-translated R commands Review of how dbplyr handles R commands that have not been translated into a like-SQL command Preview how Sys.time() is translated orders %&gt;% mutate(today = Sys.time()) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;order_id&quot;, &quot;customer_id&quot;, &quot;step_id&quot;, Sys.time() AS &quot;today&quot; ## FROM datawarehouse.orders Use SQLite’s native commands, in this case date() orders %&gt;% mutate(today = date(&#39;now&#39;)) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;order_id&quot;, &quot;customer_id&quot;, &quot;step_id&quot;, date(&#39;now&#39;) AS &quot;today&quot; ## FROM datawarehouse.orders Run the dplyr code to confirm it works orders %&gt;% mutate(today = date(&#39;now&#39;)) %&gt;% select(today) %&gt;% head() ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## today ## &lt;date&gt; ## 1 2019-12-31 ## 2 2019-12-31 ## 3 2019-12-31 ## 4 2019-12-31 ## 5 2019-12-31 ## 6 2019-12-31 5.5 Using bang-bang Intro on passing unevaluated code to a dplyr verb Preview how Sys.time() is translated when prefixing !! orders %&gt;% mutate(today = !!Sys.time()) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;order_id&quot;, &quot;customer_id&quot;, &quot;step_id&quot;, &#39;2019-12-31T15:58:33Z&#39; AS &quot;today&quot; ## FROM datawarehouse.orders View resulting table when Sys.time() is translated when prefixing !! orders %&gt;% mutate(today = !!Sys.time()) %&gt;% select(today) %&gt;% head() ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## today ## &lt;chr&gt; ## 1 2019-12-31T15:58:34Z ## 2 2019-12-31T15:58:34Z ## 3 2019-12-31T15:58:34Z ## 4 2019-12-31T15:58:34Z ## 5 2019-12-31T15:58:34Z ## 6 2019-12-31T15:58:34Z "],
["data-visualizations.html", "6 Data Visualizations 6.1 Simple plot 6.2 Plot in one code segment 6.3 Create a histogram 6.4 Raster plot 6.5 Using the compute functions", " 6 Data Visualizations 6.1 Simple plot Practice pushing the calculations to the database Load the connections and dplyr libraries library(connections) library(dplyr) library(config) Use connection_open() to open a Database connection con &lt;- connection_open( RPostgres::Postgres(), host = &quot;localhost&quot;, user = get(&quot;user&quot;, config = &quot;datawarehouse&quot;), password = get(&quot;password&quot;, config = &quot;datawarehouse&quot;), port = 5432, dbname = &quot;postgres&quot;, bigint = &quot;integer&quot; ) Use tbl() to create a pointer to the v_orders table orders &lt;- tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;v_orders&quot;)) Use collect() bring back the aggregated results into a “pass-through” variable called by_year by_year &lt;- orders %&gt;% count(date_year) %&gt;% collect() Preview the by_year variable by_year ## # A tibble: 3 x 2 ## date_year n ## &lt;int&gt; &lt;int&gt; ## 1 2017 36677 ## 2 2016 36283 ## 3 2018 27121 Load the ggplot2 library library(ggplot2) Plot results using ggplot2 ggplot(by_year) + geom_col(aes(date_year, n)) Using the code in this section, create a single piped code set which also creates the plot orders %&gt;% count(date_year) %&gt;% collect() %&gt;% ggplot() + # &lt; Don&#39;t forget to switch to `+` geom_col(aes(date_year, n)) 6.2 Plot in one code segment Practice going from dplyr to ggplot2 without using pass-through variable, great for EDA Summarize the order totals in a new variable called: sales orders %&gt;% summarise(sales = sum(order_total)) ## Warning: Missing values are always removed in SQL. ## Use `SUM(x, na.rm = TRUE)` to silence this warning ## This warning is displayed only once per session. ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## sales ## &lt;dbl&gt; ## 1 2063250 Summarize the order totals in a new variable called: sales orders %&gt;% group_by(date_year) %&gt;% summarise(sales = sum(order_total)) ## # Source: lazy query [?? x 2] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## date_year sales ## &lt;int&gt; &lt;dbl&gt; ## 1 2017 762279 ## 2 2016 742856 ## 3 2018 558124 Summarize the order totals in a new variable called: sales orders %&gt;% group_by(date_year) %&gt;% summarise(sales = sum(order_total)) %&gt;% ggplot() + geom_col(aes(date_year, sales)) Switch the calculation to reflect the average of the order sale total orders %&gt;% group_by(date_year) %&gt;% summarise(sales = mean(order_total)) %&gt;% ggplot() + geom_col(aes(date_year, sales)) ## Warning: Missing values are always removed in SQL. ## Use `mean(x, na.rm = TRUE)` to silence this warning ## This warning is displayed only once per session. 6.3 Create a histogram Use the dbplot package to easily create a histogram Load the dbplot package library(dbplot) Use the dbplot_histogram() to build the histogram orders %&gt;% dbplot_histogram(order_total) Adjust the binwidth to 300 orders %&gt;% dbplot_histogram(order_total, binwidth = 10) 6.4 Raster plot Use dbplot’s raster graph Use a dbplot_raster() to visualize order_qty versus order_total orders %&gt;% dbplot_raster(order_qty, order_total) Change the plot’s resolution to 10 orders %&gt;% dbplot_raster(order_qty, order_total, resolution = 10) 6.5 Using the compute functions Use the db_compute_raster() function to get the underlying results that feed the plot locations &lt;- orders %&gt;% db_compute_raster2(customer_lon, customer_lat, resolution = 10) Preview the locations variable locations ## # A tibble: 58 x 5 ## customer_lon customer_lat `n()` customer_lon_2 customer_lat_2 ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 -122. 37.8 1013 -122. 37.8 ## 2 -122. 37.7 2325 -122. 37.8 ## 3 -122. 37.8 1004 -122. 37.8 ## 4 -122. 37.8 1194 -122. 37.8 ## 5 -122. 37.8 3313 -122. 37.8 ## 6 -122. 37.8 2220 -122. 37.8 ## 7 -122. 37.7 1120 -122. 37.7 ## 8 -122. 37.7 2137 -122. 37.7 ## 9 -122. 37.8 1081 -122. 37.8 ## 10 -122. 37.8 1017 -122. 37.8 ## # … with 48 more rows Load the leaflet library library(leaflet) Pipe location into the leaflet() function, and then pipe that into the addTiles() function locations %&gt;% leaflet() %&gt;% addTiles() Add the addRectangles() function using the longitude and latitude variables locations %&gt;% leaflet() %&gt;% addTiles() %&gt;% addRectangles( ~customer_lon, ~customer_lat, ~customer_lon_2, ~customer_lat_2 ) Add the fillOpacity argument to the addRectangles() step, use n() as the value for it locations %&gt;% leaflet() %&gt;% addTiles() %&gt;% addRectangles( ~customer_lon, ~customer_lat, ~customer_lon_2, ~customer_lat_2, fillOpacity = ~`n()` ) Modify fillOpacity to be calculated as a percentage against the maximum number of orders locations %&gt;% leaflet() %&gt;% addTiles() %&gt;% addRectangles( ~customer_lon, ~customer_lat, ~customer_lon_2, ~customer_lat_2, fillOpacity = ~(`n()` / max(`n()`)) ) Add the popup argument with the following instruction as its value: ~paste0(&quot;&lt;p&gt;No of orders: &quot;,n(),&quot;&lt;/p&gt;&quot;) locations %&gt;% leaflet() %&gt;% addTiles() %&gt;% addRectangles( ~customer_lon, ~customer_lat, ~customer_lon_2, ~customer_lat_2, fillOpacity = ~(`n()` / max(`n()`)), popup = ~paste0(&quot;&lt;p&gt;No of orders: &quot;, `n()`,&quot;&lt;/p&gt;&quot;) ) "],
["modeling-with-databases.html", "7 Modeling with databases 7.1 Single step sampling 7.2 Using tidymodels for modeling 7.3 Score with tidypredict 7.4 Run predictions in DB", " 7 Modeling with databases 7.1 Single step sampling Use PostgreSQL TABLESAMPLE clause Use connection_open() to open a Database connection con &lt;- connection_open( RPostgres::Postgres(), host = &quot;localhost&quot;, user = get(&quot;user&quot;, config = &quot;datawarehouse&quot;), password = get(&quot;password&quot;, config = &quot;datawarehouse&quot;), port = 5432, dbname = &quot;postgres&quot;, bigint = &quot;integer&quot; ) Set the orders variable to point to the orders table orders &lt;- tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;orders&quot;)) Set the orders_view variable to point to the v_orders table orders_view &lt;- tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;v_orders&quot;)) Pipe orders into the function show_query() orders %&gt;% show_query() ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders Pipe the previous command into the class() function to see the kind of output show_query() returns orders %&gt;% show_query() %&gt;% class() ## &lt;SQL&gt; ## SELECT * ## FROM datawarehouse.orders ## [1] &quot;tbl_conn&quot; &quot;tbl_PqConnection&quot; &quot;tbl_dbi&quot; &quot;tbl_sql&quot; ## [5] &quot;tbl_lazy&quot; &quot;tbl&quot; Replace show_query() with remote_query() to compare the output types orders %&gt;% remote_query() %&gt;% class() ## [1] &quot;sql&quot; &quot;character&quot; Replace class() with build_sql(). Use con as the value for the con argument orders %&gt;% remote_query() %&gt;% build_sql(con = con) ## &lt;SQL&gt; SELECT * ## FROM datawarehouse.orders Add &quot; TABLESAMPLE BERNOULLI (0.1)&quot; to build_sql() as another ... argument orders %&gt;% remote_query() %&gt;% build_sql(con = con, &quot; TABLESAMPLE BERNOULLI (0.1)&quot;) ## &lt;SQL&gt; SELECT * ## FROM datawarehouse.orders TABLESAMPLE BERNOULLI (0.1) Pipe the code into tbl(). Use con for the con argument, and . for the rest orders %&gt;% remote_query() %&gt;% build_sql(con = con, &quot; TABLESAMPLE BERNOULLI (0.1)&quot;) %&gt;% tbl(con, .) ## # Source: SQL [?? x 3] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id customer_id step_id ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 9872 37 9 ## 2 14395 34 14 ## 3 15430 30 15 ## 4 26567 42 26 ## 5 31082 62 31 ## 6 33243 63 33 ## 7 38682 63 38 ## 8 56561 80 56 ## 9 61018 34 61 ## 10 78693 45 78 ## # … with more rows Use inner_join() to add the information from the orders_view pointer, use order_id as the matching field orders %&gt;% remote_query() %&gt;% build_sql(con = con, &quot; TABLESAMPLE BERNOULLI (0.1)&quot;) %&gt;% tbl(con, .) %&gt;% inner_join(orders_view, by = &quot;order_id&quot;) ## # Source: lazy query [?? x 12] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id customer_id.x step_id date date_year date_month customer_id.y ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 10956 77 10 2016… 2016 1 77 ## 2 28745 8 28 2016… 2016 1 8 ## 3 39836 1 39 2016… 2016 2 1 ## 4 40907 88 40 2016… 2016 2 88 ## 5 49819 74 49 2016… 2016 2 74 ## 6 55428 67 55 2016… 2016 2 67 ## 7 62177 43 62 2016… 2016 3 43 ## 8 72128 16 72 2016… 2016 3 16 ## 9 88743 39 88 2016… 2016 3 39 ## 10 90986 57 90 2016… 2016 3 57 ## # … with more rows, and 5 more variables: customer_name &lt;chr&gt;, ## # customer_lon &lt;dbl&gt;, customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, order_qty &lt;int&gt; Assign the resulting code to a variable orders_sample_db orders_sample_db &lt;- orders %&gt;% remote_query() %&gt;% build_sql(con = con, &quot; TABLESAMPLE BERNOULLI (0.1)&quot;) %&gt;% tbl(con, .) %&gt;% inner_join(orders_view, by = &quot;order_id&quot;) Use collect() to load the results of orders_sample_db to a new variable called orders_sample orders_sample &lt;- collect(orders_sample_db) Load the dbplot library library(dbplot) Use dbplot_histogram() to visualize the distribution of order_total from orders_sample orders_sample %&gt;% dbplot_histogram(order_total, binwidth = 5) Use dbplot_histogram() to visualize the distribution of order_total from orders_view orders_view %&gt;% dbplot_histogram(order_total, binwidth = 5) 7.2 Using tidymodels for modeling Fit and measure the model’s performance using functions from parsnip and yardstick Load the tidymodels library library(tidymodels) Start with the linear_reg() command, pipe into set_engine(), and use “lm” as its sole argument linear_reg() %&gt;% set_engine(&quot;lm&quot;) ## Linear Regression Model Specification (regression) ## ## Computational engine: lm Pipe into the fit() command. Use the formula: order_total ~ order_qty, and orders_sample as the data argument linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(order_total ~ order_qty, data = orders_sample) ## parsnip model object ## ## Fit in: 300ms ## Call: ## stats::lm(formula = formula, data = data) ## ## Coefficients: ## (Intercept) order_qty ## 0.4798 6.4649 Assign the previous code to a variable called parsnip_model parsnip_model &lt;- linear_reg() %&gt;% set_engine(&quot;lm&quot;) %&gt;% fit(order_total ~ order_qty, data = orders_sample) Use bind_cols() to add the predictions to order_sample. Calculate the prediction with predict() orders_sample %&gt;% bind_cols(predict(parsnip_model, orders_sample)) ## # A tibble: 95 x 13 ## order_id customer_id.x step_id date date_year date_month customer_id.y ## &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 23214 71 23 2016… 2016 1 71 ## 2 25490 12 25 2016… 2016 1 12 ## 3 38703 37 38 2016… 2016 2 37 ## 4 61006 45 61 2016… 2016 2 53 ## 5 61006 45 61 2016… 2016 3 45 ## 6 67659 59 67 2016… 2016 3 59 ## 7 90899 87 90 2016… 2016 3 87 ## 8 109866 22 109 2016… 2016 4 22 ## 9 113270 75 113 2016… 2016 4 75 ## 10 115421 19 115 2016… 2016 4 19 ## # … with 85 more rows, and 6 more variables: customer_name &lt;chr&gt;, ## # customer_lon &lt;dbl&gt;, customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, order_qty &lt;int&gt;, ## # .pred &lt;dbl&gt; Pipe the code into the metrics() function. Use order_total as the truth argument, and .pred as the estimate argument orders_sample %&gt;% bind_cols(predict(parsnip_model, orders_sample)) %&gt;% metrics(truth = order_total, estimate = .pred) ## # A tibble: 3 x 3 ## .metric .estimator .estimate ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 rmse standard 2.84 ## 2 rsq standard 0.943 ## 3 mae standard 2.24 7.3 Score with tidypredict Load the tidypredict library library(tidypredict) Use the parse_model() function to parse parsnip_model, and assign it to a variable called parsed_parsnip parsed_parsnip &lt;- parse_model(parsnip_model) Use str() to see the parsed_parsnip object’s structure str(parsed_parsnip) ## List of 2 ## $ general:List of 6 ## ..$ model : chr &quot;lm&quot; ## ..$ version : num 2 ## ..$ type : chr &quot;regression&quot; ## ..$ residual: int 93 ## ..$ sigma2 : num 8.25 ## ..$ is_glm : num 0 ## $ terms :List of 2 ## ..$ :List of 5 ## .. ..$ label : chr &quot;(Intercept)&quot; ## .. ..$ coef : num 0.48 ## .. ..$ is_intercept: num 1 ## .. ..$ fields :List of 1 ## .. .. ..$ :List of 2 ## .. .. .. ..$ type: chr &quot;ordinary&quot; ## .. .. .. ..$ col : chr &quot;(Intercept)&quot; ## .. ..$ qr :List of 2 ## .. .. ..$ qr_1: num -0.103 ## .. .. ..$ qr_2: num -0.186 ## ..$ :List of 5 ## .. ..$ label : chr &quot;order_qty&quot; ## .. ..$ coef : num 6.46 ## .. ..$ is_intercept: num 0 ## .. ..$ fields :List of 1 ## .. .. ..$ :List of 2 ## .. .. .. ..$ type: chr &quot;ordinary&quot; ## .. .. .. ..$ col : chr &quot;order_qty&quot; ## .. ..$ qr :List of 2 ## .. .. ..$ qr_1: num 0 ## .. .. ..$ qr_2: num 0.0575 ## - attr(*, &quot;class&quot;)= chr [1:3] &quot;parsed_model&quot; &quot;pm_regression&quot; &quot;list&quot; Use tidypredict_fit() to view the dplyr formula that calculates the prediction tidypredict_fit(parsed_parsnip) ## 0.479818598832359 + (order_qty * 6.46487698081735) Use head() to get the first 10 records from orders_view orders_view %&gt;% head(10) ## # Source: lazy query [?? x 10] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id date date_year date_month customer_id customer_name customer_lon ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1001 2016… 2016 1 36 Jeptha Ziema… -122. ## 2 1002 2016… 2016 1 21 Miss Azzie J… -122. ## 3 1003 2016… 2016 1 64 Amber Harber -122. ## 4 1004 2016… 2016 1 85 Mat Luettgen -122. ## 5 1005 2016… 2016 1 41 Dr. Dionte Q… -122. ## 6 1006 2016… 2016 1 70 Reggie Mills -122. ## 7 1007 2016… 2016 1 10 Ms. Ciarra B… -122. ## 8 1008 2016… 2016 1 78 Pricilla Goo… -122. ## 9 1009 2016… 2016 1 56 Kimora Bergn… -122. ## 10 1010 2016… 2016 1 71 Erle Christi… -122. ## # … with 3 more variables: customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, order_qty &lt;int&gt; Pipe the code into mutate(). Assign to a new my_pred variable the results of tidypredict_fit(). Make sure to prefix tidypredict_fit() with the bang-bang operator so that the formula is evaluated. orders_view %&gt;% head(10) %&gt;% mutate(my_pred = !! tidypredict_fit(parsed_parsnip)) ## # Source: lazy query [?? x 11] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id date date_year date_month customer_id customer_name customer_lon ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1001 2016… 2016 1 36 Jeptha Ziema… -122. ## 2 1002 2016… 2016 1 21 Miss Azzie J… -122. ## 3 1003 2016… 2016 1 64 Amber Harber -122. ## 4 1004 2016… 2016 1 85 Mat Luettgen -122. ## 5 1005 2016… 2016 1 41 Dr. Dionte Q… -122. ## 6 1006 2016… 2016 1 70 Reggie Mills -122. ## 7 1007 2016… 2016 1 10 Ms. Ciarra B… -122. ## 8 1008 2016… 2016 1 78 Pricilla Goo… -122. ## 9 1009 2016… 2016 1 56 Kimora Bergn… -122. ## 10 1010 2016… 2016 1 71 Erle Christi… -122. ## # … with 4 more variables: customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, ## # order_qty &lt;int&gt;, my_pred &lt;dbl&gt; Replace the mutate() command with tidypredict_to_column() orders_view %&gt;% head(10) %&gt;% tidypredict_to_column(parsnip_model) ## # Source: lazy query [?? x 11] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id date date_year date_month customer_id customer_name customer_lon ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1001 2016… 2016 1 36 Jeptha Ziema… -122. ## 2 1002 2016… 2016 1 21 Miss Azzie J… -122. ## 3 1003 2016… 2016 1 64 Amber Harber -122. ## 4 1004 2016… 2016 1 85 Mat Luettgen -122. ## 5 1005 2016… 2016 1 41 Dr. Dionte Q… -122. ## 6 1006 2016… 2016 1 70 Reggie Mills -122. ## 7 1007 2016… 2016 1 10 Ms. Ciarra B… -122. ## 8 1008 2016… 2016 1 78 Pricilla Goo… -122. ## 9 1009 2016… 2016 1 56 Kimora Bergn… -122. ## 10 1010 2016… 2016 1 71 Erle Christi… -122. ## # … with 4 more variables: customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, ## # order_qty &lt;int&gt;, fit &lt;dbl&gt; Load the yaml library library(yaml) Use write_yaml() to save the contents of parsed_parsnip into a file called model.yaml write_yaml(parsed_parsnip, &quot;model.yaml&quot;) Using read_yaml(), read the contents of the model.yaml file into the a new variable called loaded_model loaded_model &lt;- read_yaml(&quot;model.yaml&quot;) Use as_parsed_model() to convert the loaded_model variable into a tidypredict parsed model object, assign the results to loaded_model_2 loaded_model_2 &lt;- as_parsed_model(loaded_model) 7.4 Run predictions in DB Load the modeldb library library(modeldb) Use select() to pick the order_total and order_qty fields from the orders_sample_db table pointer orders_sample_db %&gt;% select(order_total, order_qty) ## # Source: lazy query [?? x 2] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_total order_qty ## &lt;dbl&gt; &lt;int&gt; ## 1 12.3 2 ## 2 26.9 4 ## 3 18.0 3 ## 4 4.89 1 ## 5 9.48 2 ## 6 20.8 3 ## 7 21.5 4 ## 8 21.7 4 ## 9 36.5 5 ## 10 15.9 2 ## # … with more rows Pipe the code into the linear_regression_db() function, pass order_total as the only argument orders_sample_db %&gt;% select(order_total, order_qty) %&gt;% linear_regression_db(order_total) ## # A tibble: 1 x 2 ## `(Intercept)` order_qty ## &lt;dbl&gt; &lt;dbl&gt; ## 1 -0.350 6.86 Assign the model results to a new variable called db_model db_model &lt;- orders_sample_db %&gt;% select(order_total, order_qty) %&gt;% linear_regression_db(order_total) Use as_parsed_model() to convert db_model to a parsed model object. Assign to new a variable called pm pm &lt;- as_parsed_model(db_model) Use head() to get the top 10 records, and then pipe into tidypredict_to_column() to add the results from pm orders_view %&gt;% head(10) %&gt;% tidypredict_to_column(pm) ## # Source: lazy query [?? x 11] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_id date date_year date_month customer_id customer_name customer_lon ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 1001 2016… 2016 1 36 Jeptha Ziema… -122. ## 2 1002 2016… 2016 1 21 Miss Azzie J… -122. ## 3 1003 2016… 2016 1 64 Amber Harber -122. ## 4 1004 2016… 2016 1 85 Mat Luettgen -122. ## 5 1005 2016… 2016 1 41 Dr. Dionte Q… -122. ## 6 1006 2016… 2016 1 70 Reggie Mills -122. ## 7 1007 2016… 2016 1 10 Ms. Ciarra B… -122. ## 8 1008 2016… 2016 1 78 Pricilla Goo… -122. ## 9 1009 2016… 2016 1 56 Kimora Bergn… -122. ## 10 1010 2016… 2016 1 71 Erle Christi… -122. ## # … with 4 more variables: customer_lat &lt;dbl&gt;, order_total &lt;dbl&gt;, ## # order_qty &lt;int&gt;, fit &lt;dbl&gt; "],
["advanced-operations.html", "8 Advanced Operations 8.1 Simple wrapper function 8.2 Multiple variables 8.3 Multiple queries 8.4 Multiple queries with an overlapping range 8.5 Characters to field names", " 8 Advanced Operations 8.1 Simple wrapper function Load the connections and dplyr libraries library(connections) library(dplyr) library(dbplyr) library(config) Use connection_open() to open a Database connection con &lt;- connection_open( RPostgres::Postgres(), host = &quot;localhost&quot;, user = get(&quot;user&quot;, config = &quot;datawarehouse&quot;), password = get(&quot;password&quot;, config = &quot;datawarehouse&quot;), port = 5432, dbname = &quot;postgres&quot;, bigint = &quot;integer&quot; ) Create a variable that points to the v_orders table orders &lt;- tbl(con, in_schema(&quot;datawarehouse&quot;, &quot;v_orders&quot;)) Create a simple dplyr call that gets the average of all order totals orders %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.6 Load the rlang library library(rlang) Create a new function call my_mean() that will take an argument, x, and then returns the results of enquo(x) my_mean &lt;- function(x){ enquo(x) } Test the new function. It should return the same variable name, but inside quosure. Use order_total as its argument’s value to test my_mean(order_total) ## &lt;quosure&gt; ## expr: ^order_total ## env: global In the function, re-assign x to the result of enquo(x), and then return x my_mean &lt;- function(x){ x &lt;- enquo(x) x } Test the same way again, the output should match to what it was as before my_mean(order_total) ## &lt;quosure&gt; ## expr: ^order_total ## env: global Remove the last line that has x, add the contents of the function with the initial dplyr code from step 3. Then replace order_total with !! x my_mean &lt;- function(x){ x &lt;- enquo(x) orders %&gt;% summarise(mean = mean(!! x, na.rm = TRUE)) } Test the new function by passing order_total as x my_mean(order_total) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.6 In the summarise() step, replace the name mean, with !! as_label(x), also replace the = sign, with := my_mean &lt;- function(x){ x &lt;- enquo(x) orders %&gt;% summarise(!! as_label(x) := mean(!! x, na.rm = TRUE)) } Run the function again, the name of the column should match the argument value my_mean(order_total) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_total ## &lt;dbl&gt; ## 1 20.6 Test the function by passing a formula, such as order_total / order_qty my_mean(order_total / order_qty) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## `order_total/order_qty` ## &lt;dbl&gt; ## 1 6.69 Make the function generic, add a new argument called: .data. Inisde the function, replace orders with .data my_mean &lt;- function(.data, x){ x &lt;- enquo(x) .data %&gt;% summarise(!! as_label(x) := mean(!! x, na.rm = TRUE)) } The function now behaves more like a dplyr verb. Start with orders and then pipe into the function orders %&gt;% my_mean(order_total) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_total ## &lt;dbl&gt; ## 1 20.6 Clean up the code by removing the pipe that inside the function my_mean &lt;- function(.data, x){ x &lt;- enquo(x) summarise( .data, !! as_label(x) := mean(!! x, na.rm = TRUE) ) } Confirm that there is no change in the behavior of the function orders %&gt;% my_mean(order_total) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## order_total ## &lt;dbl&gt; ## 1 20.6 Add a show_query() step to preview the resulting SQL statement orders %&gt;% my_mean(order_total) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT AVG(&quot;order_total&quot;) AS &quot;order_total&quot; ## FROM datawarehouse.v_orders Try the function with a non-DB backed variable, such as mtcars. Use mpg as the aggregating variable mtcars %&gt;% my_mean(mpg) ## mpg ## 1 20.09062 8.2 Multiple variables Create functions that handle a variable number of arguments. The goal of the exercise is to create an anti-select() function. Load the purrr package library(purrr) Use … as the second argument of a function called de_select(). Inside the function use enquos() to parse it de_select &lt;- function(.data, ...){ vars &lt;- enquos(...) vars } Test the function using airports orders %&gt;% de_select(order_id, date) ## &lt;list_of&lt;quosure&gt;&gt; ## ## [[1]] ## &lt;quosure&gt; ## expr: ^order_id ## env: 0x55febe46a9b8 ## ## [[2]] ## &lt;quosure&gt; ## expr: ^date ## env: 0x55febe46a9b8 Add a step to the function that iterates through each quosure and prefixes a minus sign to tell select() to drop that specific field. Use map() for the iteration, and quo() to create the prefixed expression. de_select &lt;- function(.data, ...){ vars &lt;- enquos(...) vars &lt;- map(vars, ~ quo(- !! .x)) vars } Run the same test to view the new results orders %&gt;% de_select(order_id, date) ## [[1]] ## &lt;quosure&gt; ## expr: ^-^order_id ## env: 0x55febda8e410 ## ## [[2]] ## &lt;quosure&gt; ## expr: ^-^date ## env: 0x55febda8b920 Add the select() step. Use !!! to parse the vars variable inside select() de_select &lt;- function(.data, ...){ vars &lt;- enquos(...) vars &lt;- map(vars, ~ quo(- !! .x)) select(.data, !!! vars) } Run the test again, this time the operation will take place. orders %&gt;% de_select(order_id, date) ## # Source: lazy query [?? x 8] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## date_year date_month customer_id customer_name customer_lon customer_lat ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2016 1 36 Jeptha Ziema… -122. 37.7 ## 2 2016 1 21 Miss Azzie J… -122. 37.8 ## 3 2016 1 64 Amber Harber -122. 37.8 ## 4 2016 1 85 Mat Luettgen -122. 37.8 ## 5 2016 1 41 Dr. Dionte Q… -122. 37.8 ## 6 2016 1 70 Reggie Mills -122. 37.7 ## 7 2016 1 10 Ms. Ciarra B… -122. 37.8 ## 8 2016 1 78 Pricilla Goo… -122. 37.8 ## 9 2016 1 56 Kimora Bergn… -122. 37.7 ## 10 2016 1 71 Erle Christi… -122. 37.7 ## # … with more rows, and 2 more variables: order_total &lt;dbl&gt;, order_qty &lt;int&gt; Add a show_query() step to see the resulting SQL orders %&gt;% de_select(order_id, date) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;date_year&quot;, &quot;date_month&quot;, &quot;customer_id&quot;, &quot;customer_name&quot;, &quot;customer_lon&quot;, &quot;customer_lat&quot;, &quot;order_total&quot;, &quot;order_qty&quot; ## FROM datawarehouse.v_orders Test the function with a different data set, such as mtcars mtcars %&gt;% de_select(mpg, wt, am) ## cyl disp hp drat qsec vs gear carb ## Mazda RX4 6 160.0 110 3.90 16.46 0 4 4 ## Mazda RX4 Wag 6 160.0 110 3.90 17.02 0 4 4 ## Datsun 710 4 108.0 93 3.85 18.61 1 4 1 ## Hornet 4 Drive 6 258.0 110 3.08 19.44 1 3 1 ## Hornet Sportabout 8 360.0 175 3.15 17.02 0 3 2 ## Valiant 6 225.0 105 2.76 20.22 1 3 1 ## Duster 360 8 360.0 245 3.21 15.84 0 3 4 ## Merc 240D 4 146.7 62 3.69 20.00 1 4 2 ## Merc 230 4 140.8 95 3.92 22.90 1 4 2 ## Merc 280 6 167.6 123 3.92 18.30 1 4 4 ## Merc 280C 6 167.6 123 3.92 18.90 1 4 4 ## Merc 450SE 8 275.8 180 3.07 17.40 0 3 3 ## Merc 450SL 8 275.8 180 3.07 17.60 0 3 3 ## Merc 450SLC 8 275.8 180 3.07 18.00 0 3 3 ## Cadillac Fleetwood 8 472.0 205 2.93 17.98 0 3 4 ## Lincoln Continental 8 460.0 215 3.00 17.82 0 3 4 ## Chrysler Imperial 8 440.0 230 3.23 17.42 0 3 4 ## Fiat 128 4 78.7 66 4.08 19.47 1 4 1 ## Honda Civic 4 75.7 52 4.93 18.52 1 4 2 ## Toyota Corolla 4 71.1 65 4.22 19.90 1 4 1 ## Toyota Corona 4 120.1 97 3.70 20.01 1 3 1 ## Dodge Challenger 8 318.0 150 2.76 16.87 0 3 2 ## AMC Javelin 8 304.0 150 3.15 17.30 0 3 2 ## Camaro Z28 8 350.0 245 3.73 15.41 0 3 4 ## Pontiac Firebird 8 400.0 175 3.08 17.05 0 3 2 ## Fiat X1-9 4 79.0 66 4.08 18.90 1 4 1 ## Porsche 914-2 4 120.3 91 4.43 16.70 0 5 2 ## Lotus Europa 4 95.1 113 3.77 16.90 1 5 2 ## Ford Pantera L 8 351.0 264 4.22 14.50 0 5 4 ## Ferrari Dino 6 145.0 175 3.62 15.50 0 5 6 ## Maserati Bora 8 301.0 335 3.54 14.60 0 5 8 ## Volvo 142E 4 121.0 109 4.11 18.60 1 4 2 8.3 Multiple queries Suggested approach to avoid passing multiple, and similar, queries to the database Create a simple dplyr piped operation that returns the mean of order_total for the months of January, February and March as a group orders %&gt;% filter(date_month %in% c(1,2,3)) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.5 Assign the first operation to a variable called a, and create copy of the operation but changing the selected months to January, March and April. Assign the second one to a variable called b. a &lt;- orders %&gt;% filter(date_month %in% c(1,2,3)) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) b &lt;- orders %&gt;% filter(date_month %in% c(1,3,4)) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) Use union() to pass a and b at the same time to the database union(a, b) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.5 ## 2 20.5 Pipe the previous instruction to show_query() to confirm that the resulting query is a single one union(a, b) %&gt;% show_query() ## &lt;SQL&gt; ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; IN (1.0, 2.0, 3.0))) ## UNION ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; IN (1.0, 3.0, 4.0))) Assign to a new variable called months an overlapping set of months months &lt;- list( c(1,2,3), c(1,3,4), c(2,4,6) ) Use map() to cycle through each set of overlapping months. Notice that it returns three separate results, meaning that it went to the database three times months %&gt;% map( ~ orders %&gt;% filter(date_month %in% .x) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) ## [[1]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.5 ## ## [[2]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.5 ## ## [[3]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.7 Add a reduce() operation and use union() command to create a single query months %&gt;% map( ~ orders %&gt;% filter(date_month %in% .x) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) %&gt;% reduce(function(x, y) union(x, y)) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.7 ## 2 20.5 ## 3 20.5 Use show_query() to see the resulting single query sent to the database months %&gt;% map( ~ orders %&gt;% filter(date_month %in% .x) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) %&gt;% reduce(function(x, y) union(x, y)) %&gt;% show_query() ## &lt;SQL&gt; ## ((SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; IN (1.0, 2.0, 3.0))) ## UNION ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; IN (1.0, 3.0, 4.0)))) ## UNION ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; IN (2.0, 4.0, 6.0))) 8.4 Multiple queries with an overlapping range Create a table with a from and to ranges ranges &lt;- tribble( ~ from, ~to, 1, 4, 2, 5, 3, 7 ) See how map2() works by passing the two variables as the x and y arguments, and adding them as the function map2(ranges$from, ranges$to, ~.x + .y) ## [[1]] ## [1] 5 ## ## [[2]] ## [1] 7 ## ## [[3]] ## [1] 10 Replace x + y with the dplyr operation from the previous exercise. In it, re-write the filter to use x and y as the month ranges map2( ranges$from, ranges$to, ~ orders %&gt;% filter(date_month &gt;= .x &amp; date_month &lt;= .y) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) ## [[1]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.5 ## ## [[2]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.6 ## ## [[3]] ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.6 Add the reduce() operation map2( ranges$from, ranges$to, ~ orders %&gt;% filter(date_month &gt;= .x &amp; date_month &lt;= .y) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) %&gt;% reduce(function(x, y) union(x, y)) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## mean ## &lt;dbl&gt; ## 1 20.6 ## 2 20.6 ## 3 20.5 Add a show_query() step to see how the final query was constructed. map2( ranges$from, ranges$to, ~ orders %&gt;% filter(date_month &gt;= .x &amp; date_month &lt;= .y) %&gt;% summarise(mean = mean(order_total, na.rm = TRUE)) ) %&gt;% reduce(function(x, y) union(x, y)) %&gt;% show_query() ## &lt;SQL&gt; ## ((SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; &gt;= 1.0 AND &quot;date_month&quot; &lt;= 4.0)) ## UNION ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; &gt;= 2.0 AND &quot;date_month&quot; &lt;= 5.0))) ## UNION ## (SELECT AVG(&quot;order_total&quot;) AS &quot;mean&quot; ## FROM datawarehouse.v_orders ## WHERE (&quot;date_month&quot; &gt;= 3.0 AND &quot;date_month&quot; &lt;= 7.0)) 8.5 Characters to field names Create two character variables. One with the name of a field in flights and another with a new name to be given to the field my_field &lt;- &quot;new&quot; orders_field &lt;- &quot;order_total&quot; Add a mutate() step that adds the new field. And then another step selecting just the new field orders %&gt;% mutate(my_field = !! orders_field) %&gt;% select(my_field) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## my_field ## &lt;chr&gt; ## 1 order_total ## 2 order_total ## 3 order_total ## 4 order_total ## 5 order_total ## 6 order_total ## 7 order_total ## 8 order_total ## 9 order_total ## 10 order_total ## # … with more rows Add a mutate() step that adds the new field. And then another step selecting just the new field orders %&gt;% mutate(!! my_field := !! orders_field) %&gt;% select(my_field) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## new ## &lt;chr&gt; ## 1 order_total ## 2 order_total ## 3 order_total ## 4 order_total ## 5 order_total ## 6 order_total ## 7 order_total ## 8 order_total ## 9 order_total ## 10 order_total ## # … with more rows Wrap orders_field inside a sym() function orders %&gt;% mutate(!! my_field := !! sym(orders_field)) %&gt;% select(my_field) ## # Source: lazy query [?? x 1] ## # Database: postgres [rstudio_admin@localhost:5432/postgres] ## new ## &lt;dbl&gt; ## 1 10.9 ## 2 29.4 ## 3 31.0 ## 4 42 ## 5 27.2 ## 6 12.7 ## 7 11.3 ## 8 5.47 ## 9 19.9 ## 10 18.6 ## # … with more rows Pipe the code into show_query() orders %&gt;% mutate(!! my_field := !! sym(orders_field)) %&gt;% select(my_field) %&gt;% show_query() ## &lt;SQL&gt; ## SELECT &quot;order_total&quot; AS &quot;new&quot; ## FROM datawarehouse.v_orders "],
["intro-to-sparklyr.html", "9 Intro to sparklyr 9.1 New Spark session 9.2 Data transfer 9.3 Spark and dplyr", " 9 Intro to sparklyr 9.1 New Spark session Learn to open a new Spark session Load the sparklyr library library(sparklyr) Use spark_connect() to create a new local Spark session sc &lt;- spark_connect(master = &quot;local&quot;) ## * Using Spark: 2.4.0 Click on the Spark button to view the current Spark session’s UI Click on the Log button to see the message history 9.2 Data transfer Practice uploading data to Spark Load the dplyr library library(dplyr) Copy the mtcars dataset into the session spark_mtcars &lt;- copy_to(sc, mtcars, &quot;my_mtcars&quot;) In the Connections pane, expande the my_mtcars table Go to the Spark UI, note the new jobs In the UI, click the Storage button, note the new table Click on the In-memory table my_mtcars link 9.3 Spark and dplyr See how Spark handles dplyr commands Run the following code snipett spark_mtcars %&gt;% group_by(am) %&gt;% summarise(mpg_mean = mean(mpg, na.rm = TRUE)) ## # Source: spark&lt;?&gt; [?? x 2] ## am mpg_mean ## &lt;dbl&gt; &lt;dbl&gt; ## 1 0 17.1 ## 2 1 24.4 Go to the Spark UI and click the SQL button Click on the top item inside the Completed Queries table At the bottom of the diagram, expand Details "],
["text-mining-with-sparklyr.html", "10 Text mining with sparklyr 10.1 Data Import 10.2 Tidying data 10.3 Transform the data 10.4 Data Exploration", " 10 Text mining with sparklyr For this example, there are two files that will be analyzed. They are both the full works of Sir Arthur Conan Doyle and Mark Twain. The files were downloaded from the Gutenberg Project site via the gutenbergr package. Intentionally, no data cleanup was done to the files prior to this analysis. See the appendix below to see how the data was downloaded and prepared. readLines(&quot;/usr/share/class/books/arthur_doyle.txt&quot;, 30) ## [1] &quot;THE RETURN OF SHERLOCK HOLMES,&quot; ## [2] &quot;&quot; ## [3] &quot;A Collection of Holmes Adventures&quot; ## [4] &quot;&quot; ## [5] &quot;&quot; ## [6] &quot;by Sir Arthur Conan Doyle&quot; ## [7] &quot;&quot; ## [8] &quot;&quot; ## [9] &quot;&quot; ## [10] &quot;&quot; ## [11] &quot;CONTENTS:&quot; ## [12] &quot;&quot; ## [13] &quot; The Adventure Of The Empty House&quot; ## [14] &quot;&quot; ## [15] &quot; The Adventure Of The Norwood Builder&quot; ## [16] &quot;&quot; ## [17] &quot; The Adventure Of The Dancing Men&quot; ## [18] &quot;&quot; ## [19] &quot; The Adventure Of The Solitary Cyclist&quot; ## [20] &quot;&quot; ## [21] &quot; The Adventure Of The Priory School&quot; ## [22] &quot;&quot; ## [23] &quot; The Adventure Of Black Peter&quot; ## [24] &quot;&quot; ## [25] &quot; The Adventure Of Charles Augustus Milverton&quot; ## [26] &quot;&quot; ## [27] &quot; The Adventure Of The Six Napoleons&quot; ## [28] &quot;&quot; ## [29] &quot; The Adventure Of The Three Students&quot; ## [30] &quot;&quot; 10.1 Data Import Read the book data into Spark Load the sparklyr library library(sparklyr) Open a Spark session sc &lt;- spark_connect(master = &quot;local&quot;) ## Re-using existing Spark connection to local Use the spark_read_text() function to read the mark_twain.txt file, assign it to a variable called twain twain &lt;- spark_read_text(sc, &quot;twain&quot;, &quot;/usr/share/class/books/mark_twain.txt&quot;) Use the spark_read_text() function to read the arthur_doyle.txt file, assign it to a variable called doyle doyle &lt;- spark_read_text(sc, &quot;doyle&quot;, &quot;/usr/share/class/books/arthur_doyle.txt&quot;) 10.2 Tidying data Prepare the data for analysis Load the dplyr library library(dplyr) Add a column to twain named author with a value of “twain”. Assign it to a new variable called twain_id twain_id &lt;- twain %&gt;% mutate(author = &quot;twain&quot;) Add a column to doyle named author with a value of “doyle”. Assign it to a new variable called doyle_id doyle_id &lt;- doyle %&gt;% mutate(author = &quot;doyle&quot;) Use sdf_bind_rows() to append the two files together in a variable called both both &lt;- doyle_id %&gt;% sdf_bind_rows(twain_id) Preview both both ## # Source: spark&lt;?&gt; [?? x 2] ## line author ## &lt;chr&gt; &lt;chr&gt; ## 1 &quot;THE RETURN OF SHERLOCK HOLMES,&quot; doyle ## 2 &quot;&quot; doyle ## 3 &quot;A Collection of Holmes Adventures&quot; doyle ## 4 &quot;&quot; doyle ## 5 &quot;&quot; doyle ## 6 &quot;by Sir Arthur Conan Doyle&quot; doyle ## 7 &quot;&quot; doyle ## 8 &quot;&quot; doyle ## 9 &quot;&quot; doyle ## 10 &quot;&quot; doyle ## # … with more rows Filter out empty lines into a variable called all_lines all_lines &lt;- both %&gt;% filter(nchar(line) &gt; 0) Use Hive’s regexp_replace to remove punctuation, assign it to the same all_lines variable all_lines &lt;- all_lines %&gt;% mutate(line = regexp_replace(line, &quot;[_\\&quot;\\&#39;():;,.!?\\\\-]&quot;, &quot; &quot;)) 10.3 Transform the data Use feature transformers to make additional preparations Use ft_tokenizer() to separate each word. in the line. Set the output_col to “word_list”. Assign to a variable called word_list word_list &lt;- all_lines %&gt;% ft_tokenizer( input_col = &quot;line&quot;, output_col = &quot;word_list&quot; ) Remove “stop words” with the ft_stop_words_remover() transformer. Set the output_col to “wo_stop_words”. Assign to a variable called wo_stop wo_stop &lt;- word_list %&gt;% ft_stop_words_remover( input_col = &quot;word_list&quot;, output_col = &quot;wo_stop_words&quot; ) Un-nest the tokens inside wo_stop_words using explode(). Assign to a variable called exploded exploded &lt;- wo_stop %&gt;% mutate(word = explode(wo_stop_words)) Select the word and author columns, and remove any word with less than 3 characters. Assign to all_words all_words &lt;- exploded %&gt;% select(word, author) %&gt;% filter(nchar(word) &gt; 2) Cache the all_words variable using compute() all_words &lt;- all_words %&gt;% compute(&quot;all_words&quot;) 10.4 Data Exploration Used word clouds to explore the data Create a variable with the word count by author, name it word_count word_count &lt;- all_words %&gt;% count(author, word, sort = TRUE) Filter word_cout to only retain “twain”, assign it to twain_most twain_most &lt;- word_count %&gt;% filter(author == &quot;twain&quot;) Use wordcloud to visualize the top 50 words used by Twain twain_most %&gt;% head(50) %&gt;% collect() %&gt;% with(wordcloud::wordcloud( word, n, colors = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;,&quot;#56B4E9&quot;)) ) Filter word_cout to only retain “doyle”, assign it to doyle_most doyle_most &lt;- word_count %&gt;% filter(author == &quot;doyle&quot;) Used wordcloud to visualize the top 50 words used by Doyle that have more than 5 characters doyle_most %&gt;% filter(nchar(word) &gt; 5) %&gt;% head(50) %&gt;% collect() %&gt;% with(wordcloud::wordcloud( word, n, colors = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;,&quot;#56B4E9&quot;) )) Use anti_join() to figure out which words are used by Doyle but not Twain. Order the results by number of words. doyle_unique &lt;- doyle_most %&gt;% anti_join(twain_most, by = &quot;word&quot;) %&gt;% arrange(desc(n)) Use wordcloud to visualize top 50 records in the previous step doyle_unique %&gt;% head(50) %&gt;% collect() %&gt;% with(wordcloud::wordcloud( word, n, colors = c(&quot;#999999&quot;, &quot;#E69F00&quot;, &quot;#56B4E9&quot;,&quot;#56B4E9&quot;)) ) Find out how many times Twain used the word “sherlock” all_words %&gt;% filter(author == &quot;twain&quot;, word == &quot;sherlock&quot;) %&gt;% tally() ## # Source: spark&lt;?&gt; [?? x 1] ## n ## &lt;dbl&gt; ## 1 47 Against the twain variable, use Hive’s instr and lower to make all ever word lower cap, and then look for “sherlock” in the line twain %&gt;% mutate(line = lower(line)) %&gt;% filter(instr(line, &quot;sherlock&quot;) &gt; 0) %&gt;% pull(line) ## [1] &quot;late sherlock holmes, and yet discernible by a member of a race charged&quot; ## [2] &quot;sherlock holmes.&quot; ## [3] &quot;\\&quot;uncle sherlock! the mean luck of it!--that he should come just&quot; ## [4] &quot;another trouble presented itself. \\&quot;uncle sherlock &#39;ll be wanting to talk&quot; ## [5] &quot;flint buckner&#39;s cabin in the frosty gloom. they were sherlock holmes and&quot; ## [6] &quot;\\&quot;uncle sherlock&#39;s got some work to do, gentlemen, that &#39;ll keep him till&quot; ## [7] &quot;\\&quot;by george, he&#39;s just a duke, boys! three cheers for sherlock holmes,&quot; ## [8] &quot;he brought sherlock holmes to the billiard-room, which was jammed with&quot; ## [9] &quot;of interest was there--sherlock holmes. the miners stood silent and&quot; ## [10] &quot;the room; the chair was on it; sherlock holmes, stately, imposing,&quot; ## [11] &quot;\\&quot;you have hunted me around the world, sherlock holmes, yet god is my&quot; ## [12] &quot;\\&quot;if it&#39;s only sherlock holmes that&#39;s troubling you, you needn&#39;t worry&quot; ## [13] &quot;they sighed; then one said: \\&quot;we must bring sherlock holmes. he can be&quot; ## [14] &quot;i had small desire that sherlock holmes should hang for my deeds, as you&quot; ## [15] &quot;\\&quot;my name is sherlock holmes, and i have not been doing anything.\\&quot;&quot; ## [16] &quot;late sherlock holmes, and yet discernible by a member of a race charged&quot; ## [17] &quot;plus fort que sherlock holmes&quot; ## [18] &quot;sherlock holmes entre en scene&quot; ## [19] &quot;sherlock holmes&quot; ## [20] &quot;--l&#39;oncle sherlock! quelle guigne!&quot; ## [21] &quot;bien! cette fois sherlock sera tres embarrasse; il manquera de preuve et&quot; ## [22] &quot;--l&#39;oncle sherlock va vouloir, ce soir, causer avec moi de notre&quot; ## [23] &quot;passage etroit sur la chambre de sherlock holmes; ils s&#39;y embusquerent&quot; ## [24] &quot;d&#39;archy, il ne peut etre nullement compare au genie de sherlock holmes,&quot; ## [25] &quot;flint buckner. c&#39;etait sherlock holmes et son neveu.&quot; ## [26] &quot;--messieurs, mon oncle sherlock a un travail pressant a faire qui le&quot; ## [27] &quot;--mes amis! trois vivats a sherlock holmes, le plus grand homme qui ait&quot; ## [28] &quot;mettaient de coeur a leur reception. arrive dans sa chambre, sherlock&quot; ## [29] &quot;il introduisit sherlock holmes dans la salle de billard qui etait comble&quot; ## [30] &quot;de mineurs, tous impatients de le voir arriver. sherlock commanda les&quot; ## [31] &quot;sherlock holmes. les mineurs se tenaient en demi-cercle en observant un&quot; ## [32] &quot;sherlock au milieu de nous? dit ferguson.&quot; ## [33] &quot;arracher; quand sherlock y met la main, il faut qu&#39;ils parlent, qu&#39;ils&quot; ## [34] &quot;plus complexe; sherlock va pouvoir etaler devant nous son art et sa&quot; ## [35] &quot;regardant comment sherlock procede. mais non, au lieu de cela, il a&quot; ## [36] &quot;sherlock holmes etait assis sur cette chaise, l&#39;air grave, imposant et&quot; ## [37] &quot;sherlock holmes leva la main pour concentrer sur lui l&#39;attention du&quot; ## [38] &quot;pas baisse pavillon devant sherlock holmes.\\&quot; la serenite de ce dernier&quot; ## [39] &quot;objets, il y a une heure a peine pendant que maitre sherlock holmes se&quot; ## [40] &quot;sherlock regardait avec la volonte bien arretee de conserver son&quot; ## [41] &quot;silence complet qui suivit, maitre sherlock prit la parole, disant avec&quot; ## [42] &quot;--vous m&#39;avez pourchasse dans tout l&#39;univers, sherlock holmes, et&quot; ## [43] &quot;--si c&#39;est uniquement sherlock holmes qui vous inquiete, inutile de vous&quot; ## [44] &quot;\\&quot;elles soupirerent, puis l&#39;une dit: \\&quot;il faut que nous amenions sherlock&quot; ## [45] &quot;d&#39;assister de sang-froid a la pendaison de sherlock holmes. j&#39;avais&quot; ## [46] &quot;--je m&#39;appelle sherlock holmes; je n&#39;ai rien a me reprocher.&quot; ## [47] &quot;plus fort que sherlock holmes&quot; Close Spark session spark_disconnect(sc) Most of these lines are in a short story by Mark Twain called A Double Barrelled Detective Story. As per the Wikipedia page about this story, this is a satire by Twain on the mystery novel genre, published in 1902. "],
["spark-data-caching.html", "11 Spark data caching 11.1 Map data 11.2 Caching data", " 11 Spark data caching 11.1 Map data See the machanics of how Spark is able to use files as a data source Examine the contents of the /usr/share/class/files folder Load the sparklyr library library(sparklyr) Use spark_connect() to create a new local Spark session sc &lt;- spark_connect(master = &quot;local&quot;) ## * Using Spark: 2.4.0 Load the readr and purrr libraries library(readr) ## Registered S3 methods overwritten by &#39;readr&#39;: ## method from ## format.col_spec vroom ## print.col_spec vroom ## print.collector vroom ## print.date_names vroom ## print.locale vroom ## str.col_spec vroom ## ## Attaching package: &#39;readr&#39; ## The following objects are masked from &#39;package:vroom&#39;: ## ## as.col_spec, col_character, col_date, col_datetime, col_double, ## col_factor, col_guess, col_integer, col_logical, col_number, ## col_skip, col_time, cols, cols_condense, cols_only, date_names, ## date_names_lang, date_names_langs, default_locale, fwf_cols, ## fwf_empty, fwf_positions, fwf_widths, locale, output_column, spec ## The following object is masked from &#39;package:yardstick&#39;: ## ## spec ## The following object is masked from &#39;package:scales&#39;: ## ## col_factor library(purrr) Read the top 5 rows of the transactions_1 CSV file top_rows &lt;- read_csv(&quot;/usr/share/class/files/transactions_1.csv&quot;, n_max = 5) ## Parsed with column specification: ## cols( ## order_id = col_double(), ## customer_id = col_double(), ## customer_name = col_character(), ## customer_phone = col_character(), ## customer_cc = col_double(), ## customer_lon = col_double(), ## customer_lat = col_double(), ## date = col_date(format = &quot;&quot;), ## date_year = col_double(), ## date_month = col_double(), ## date_month_name = col_character(), ## date_day = col_character(), ## product_id = col_double(), ## price = col_double() ## ) Create a list based on the column names, and add a list item with “character” as its value. Name the variable file_columns file_columns &lt;- top_rows %&gt;% rename_all(tolower) %&gt;% map(function(x) &quot;character&quot;) Preview the contents of the file_columns variable head(file_columns) ## $order_id ## [1] &quot;character&quot; ## ## $customer_id ## [1] &quot;character&quot; ## ## $customer_name ## [1] &quot;character&quot; ## ## $customer_phone ## [1] &quot;character&quot; ## ## $customer_cc ## [1] &quot;character&quot; ## ## $customer_lon ## [1] &quot;character&quot; Use spark_read() to “map” the file’s structure and location to the Spark context. Assign it to the spark_lineitems variable spark_lineitems &lt;- spark_read_csv( sc, name = &quot;orders&quot;, path = &quot;/usr/share/class/files&quot;, memory = FALSE, columns = file_columns, infer_schema = FALSE ) In the Connections pane, click on the table icon by the transactions variable Verify that the new variable pointer works by using tally() spark_lineitems %&gt;% tally() ## # Source: spark&lt;?&gt; [?? x 1] ## n ## &lt;dbl&gt; ## 1 250000 11.2 Caching data Learn how to cache a subset of the data in Spark Create a subset of the orders table object. Summarize by date, careate a total price and number of items sold. daily_orders &lt;- spark_lineitems %&gt;% mutate(price = as.double(price)) %&gt;% group_by(date) %&gt;% summarise(total_sales = sum(price, na.rm = TRUE), no_items = n()) Use compute() to extract the data into Spark memory cached_orders &lt;- compute(daily_orders, &quot;daily&quot;) Confirm new variable pointer works head(cached_orders) ## # Source: spark&lt;?&gt; [?? x 3] ## date total_sales no_items ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2016-01-27 39311. 5866 ## 2 2016-01-28 38424. 5771 ## 3 2016-02-03 37666. 5659 ## 4 2016-01-29 37582. 5652 ## 5 2016-02-04 38193. 5719 ## 6 2016-02-10 38500. 5686 Go to the Spark UI Click the Storage button Notice that “orders” is now cached into Spark memory "]
]
